"""Malware scanning engine.

This module provides simple functionality for scanning directories for files
containing known malicious hashes. It walks a directory tree, computes the
SHA256 hash of each file, and compares it against a supplied database of
malicious signatures. The database can be provided as a dictionary mapping
hashes to metadata (e.g. malware names) or as a set of hashes. When a match
is found, the file and associated metadata are returned in the results.

Because this is a selfâ€‘contained engine, it does not require internet access
or external software. Users can extend the database by supplying their own
JSON/YAML files with lists of hashes. If a database is not provided, the
scanner loads a default database from within the package (an empty list).
"""

from __future__ import annotations

import hashlib
import json
import os
from pathlib import Path
from typing import Dict, Iterable, Optional, Tuple, Union


def _compute_sha256(path: Path) -> str:
    """Compute the SHA256 hash of a file.

    Reads the file in chunks to avoid loading large files entirely into
    memory.

    Args:
        path: Path to the file.

    Returns:
        Hexadecimal string representation of the file's SHA256 hash.
    """
    sha256 = hashlib.sha256()
    with path.open("rb") as f:
        for chunk in iter(lambda: f.read(8192), b""):
            sha256.update(chunk)
    return sha256.hexdigest()


def _load_hash_db(db_path: Optional[Path] = None) -> Dict[str, str]:
    """Load a database of malicious hashes.

    The database is expected to be a JSON file where each key is a SHA256
    hash and the value is a string describing the malware (e.g. a name or
    category). If the file does not exist or cannot be parsed, an empty
    dictionary is returned.

    Args:
        db_path: Path to the JSON database file. If None, an empty
            dictionary is returned.

    Returns:
        Dictionary mapping SHA256 hashes to malware names or descriptions.
    """
    if db_path is None or not db_path.exists():
        return {}
    try:
        with db_path.open("r", encoding="utf-8") as f:
            data = json.load(f)
        if isinstance(data, dict):
            return {k.lower(): v for k, v in data.items()}
        # If the JSON is a list of hashes, convert to dict with empty values
        if isinstance(data, list):
            return {h.lower(): "" for h in data}
    except Exception:
        return {}
    return {}


def scan_path(
    target_path: Union[str, Path],
    hash_db: Optional[Dict[str, str]] = None,
    recursive: bool = True,
) -> Dict[str, Tuple[str, Optional[str]]]:
    """Scan a file or directory for known malware.

    Args:
        target_path: Path to a file or directory to scan.
        hash_db: Optional dictionary of known malicious hashes. Keys should be
            lowercase SHA256 hashes; values are descriptive strings. If None,
            an empty database is used and no files will be flagged as malware.
        recursive: If True and target_path is a directory, recurse into
            subdirectories. If False, only scan files in the top-level
            directory.

    Returns:
        A mapping from file paths (as strings) to tuples containing the
        computed SHA256 hash and the associated malware description if the
        hash was found in the database (otherwise None).
    """
    target = Path(target_path)
    if hash_db is None:
        hash_db = {}
    results: Dict[str, Tuple[str, Optional[str]]] = {}

    def _scan_file(file_path: Path) -> None:
        try:
            hash_val = _compute_sha256(file_path)
            malware_info = hash_db.get(hash_val.lower())
            results[str(file_path)] = (hash_val, malware_info)
        except Exception:
            # If file cannot be read (e.g. permission denied), record as None
            results[str(file_path)] = ("", None)

    if target.is_file():
        _scan_file(target)
    elif target.is_dir():
        for root, dirs, files in os.walk(target):
            for fname in files:
                fpath = Path(root) / fname
                _scan_file(fpath)
            if not recursive:
                break
    return results


__all__ = ["scan_path", "_load_hash_db"]